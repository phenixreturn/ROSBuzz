include "vec2.bzz"
include "update.bzz"
include "barrier.bzz"	# don't use a stigmergy id=11 with this header.
include "uavstates.bzz"	# require an 'action' function to be defined here.
include "vstigenv.bzz"
 
# Lennard-Jones parameters
TARGET     = 12.0
EPSILON    = 18.0
 
# Lennard-Jones interaction magnitude
function lj_magnitude(dist, target, epsilon) {
  return -(epsilon / dist) * ((target / dist)^4 - (target / dist)^2)
  #return -(4 * epsilon) * ((target / dist)^12 - (target / dist)^6)
}
 
# Neighbor data to LJ interaction vector
function lj_vector(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET, EPSILON), data.azimuth)
}
 
# Accumulator of neighbor LJ interactions
function lj_sum(rid, data, accum) {
  return math.vec2.add(data, accum)
}
 
# Calculates and actuates the flocking interaction
function action() {
  statef=action
  # Calculate accumulator
  var accum = neighbors.map(lj_vector).reduce(lj_sum, math.vec2.new(0.0, 0.0))
  if(neighbors.count() > 0)
    accum = math.vec2.scale(accum, 1.0 / neighbors.count())

  if(math.vec2.length(accum) > 1.0) {
  	  accum = math.vec2.scale(accum, 1.0 / math.vec2.length(accum))
  }

  # Move according to vector
  print("Robot ", id, "must push ", math.vec2.length(accum) )#, "; ", math.vec2.angle(accum))
  uav_moveto(accum.x, accum.y, 0.0)
  UAVSTATE = "LENNARDJONES"

#  if(timeW>=WAIT_TIMEOUT) {	#FOR MOVETO TESTS
#  	timeW =0
#  	statef=land
#  	} else if(timeW>=WAIT_TIMEOUT/2) {
#		  UAVSTATE ="GOEAST"
#  	timeW = timeW+1
#  	uav_moveto(0.0, 5.0, 0.0)
#  	} else {
#		  UAVSTATE ="GONORTH"
#  	timeW = timeW+1
#  	uav_moveto(5.0, 0.0, 0.0)
#  	}
}

########################################
#
# MAIN FUNCTIONS
#
########################################

# Executed once at init time.
function init() {
	uav_initswarm()
  uav_initstig()
	# TARGET_ALTITUDE = 2.5 + id * 5
  statef=turnedoff
	UAVSTATE = "TURNEDOFF"
}

# Executed at each time step.
function step() {
	uav_rccmd()
	uav_neicmd()
  uav_updatestig()

	statef()
  
	log("Current state: ", UAVSTATE)
	log("Swarm size: ",ROBOTS)
  if(id==0)
    stattab_print()
}
 
# Executed once when the robot (or the simulator) is reset.
function reset() {
}
 
# Executed once at the end of experiment.
function destroy() {
}
